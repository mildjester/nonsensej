<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AWS on Nonsense J</title>
    <link>/tags/aws/</link>
    <description>Recent content in AWS on Nonsense J</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Wed, 26 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/aws/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>EC2とECSのレコードを全てCSVに出力する</title>
      <link>/posts/2020/08/26/ec2-ecs-to-csv/</link>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/08/26/ec2-ecs-to-csv/</guid>
      <description>環境  Linux Mint 20 Ulyana aws-cli/2.0.41 jq 1.6   前回の続きです。
前回AWS Route53のレコードをCSVに出力するシェルスクリプトを作ったので、同様にEC2・ECSの情報を出力するシェルスクリプトを作ってみます。
EC2 以下のようなシェルです。
region一覧は固定で持っているので、今後増減があった場合は手動で修正が必要です。
#!/bin/bash #region一覧 regionList=( us-east-2 us-east-1 us-west-1 us-west-2 af-south-1 ap-east-1 ap-south-1 ap-northeast-3 ap-northeast-2 ap-southeast-1 ap-southeast-2 ap-northeast-1 ca-central-1 cn-north-1 cn-northwest-1 eu-central-1 eu-west-1 eu-west-2 eu-south-1 eu-west-3 eu-north-1 me-south-1 sa-east-1 ) echo &#39;&amp;quot;AvailabilityZone&amp;quot;, &amp;quot;Name&amp;quot;, &amp;quot;PublicDnsName&amp;quot;,&amp;quot;PublicIpAddress&amp;quot;,&amp;quot;PrivateDnsName&amp;quot;,&amp;quot;PrivateIpAddress&amp;quot;&#39; for region in ${regionList[@]}; do EC2List=`aws ec2 describe-instances --region ${region} --output json --query &#39;Reservations[].Instances[]&#39;` EC2ListLen=`echo $EC2List | jq length` for i in $( seq 0 $(($EC2ListLen - 1)) ); do EC2=`echo $EC2List | jq .</description>
    </item>
    
    <item>
      <title>Route53のレコードを全てCSVに出力する</title>
      <link>/posts/2020/08/21/route53-to-csv/</link>
      <pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/08/21/route53-to-csv/</guid>
      <description>環境  Linux Mint 20 Ulyana aws-cli/2.0.41 jq 1.6   Route53に大量のホストゾーンとレコードが登録されているアカウントで、Route53に登録されている内容を一覧化する必要があったので対応しました。
ワンライナーで実現しようと思ったのですが、希望した形にできなかったのでシェルスクリプトにしました。
必要なソフトのインストール AWS CLI AWS CLIが無い場合はインストールしておきます。
https://docs.aws.amazon.com/ja_jp/cli/latest/userguide/install-cliv2.html
AWS CLIの初期設定はこちら
https://docs.aws.amazon.com/ja_jp/cli/latest/userguide/cli-configure-quickstart.html
jq jqはjsonを整形するツールです。
Linux Mintであれば以下コマンドでインストールできます。
apt install jq Route53の内容を取得するスクリプト作成 AWS CLIでRoute53の内容をjson形式で取得し、それをjqで整形しながらCSVに出力するシェルスクリプトを作成します。
スクリプトの内容は以下の通りです。
#!/bin/bash # CSVのヘッダ出力 echo &#39;&amp;quot;HostedZone&amp;quot;,&amp;quot;DomainName&amp;quot;,&amp;quot;DomainType&amp;quot;,&amp;quot;TTL&amp;quot;,&amp;quot;Value&amp;quot;&#39; # ホストゾーン一覧を取得 HostedZones=`aws route53 list-hosted-zones --output json --query &#39;HostedZones&#39;` HostedZonesLen=`echo $HostedZones | jq length` for i in $( seq 0 $(($HostedZonesLen - 1)) ); do Zone=`echo $HostedZones | jq .[$i]` ZoneId=`echo $Zone | jq -c -r &#39;.</description>
    </item>
    
    <item>
      <title>AWS lambdaからDBアクセスも外部アクセスもできるようにする。</title>
      <link>/posts/2020/07/12/vpc-lambda/</link>
      <pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/07/12/vpc-lambda/</guid>
      <description>AWS lambdaからAWS RDSへアクセスさせるためにはRDSへアクセスできるVPCのサブネットにlambdaを追加します。
しかし、VPC内のlambdaは何もしないと外部アクセスができなくなります。
lambdaがRDSと同時に外部システムのAPIなどを利用する際に困りますので、
VPC内のlambdaから外部アクセスができるように設定します。
VPC設定 VPC内のlambdaから外部アクセスをさせる設定方法は、実はAWS公式で説明されています。
基本的にはこの手順を実行すれば良いだけです。
https://aws.amazon.com/jp/premiumsupport/knowledge-center/internet-access-lambda-function/
手順詳細は公式ページを見ればよいので、ここではざっくりと流れを書いておきます。
①〜②はすでにあれば既存の使い回しでも良いです。
①（なければ）RDSにアクセスできるVPCを作る。
②（なければ）インターネットゲートウェイを作成して①のVPCにアタッチする。
③RDSにアクセスできるVPCにサブネットを2つ作る。(public用とprivate用)
④NATゲートウェイを新規作成し、②で作成したpublic用サブネットを紐づける。
⑤ルートテーブルを新規作成し、public用サブネットを紐付ける。
作成したら以下のルートを追加する。
   項目 設定値     宛先 0.0.0.0/0   ターゲット ③のインターネットゲートウェイ   ⑥ルートテーブルをもう１つ新規作成し、private用サブネットを紐付ける。    　作成したら以下のルートを追加する。        項目 設定値     宛先 0.0.0.0/0   ターゲット ④のNATゲートウェイ    VPC設定はここまでです。
ここで作成したprivate用サブネットの方にlambdaを追加すればRDSと外部の両方にアクセスできるようになります。
lambda設定(Serverless Framework) 今回はServerless Frameworkを使ってlambdaを構築します。
Serverless Frameworkの基本的な構築については前回の記事を参照してください。</description>
    </item>
    
    <item>
      <title>EC2上でオレオレ証明書を作る</title>
      <link>/posts/2020/06/14/oreore-certification/</link>
      <pubDate>Sun, 14 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/06/14/oreore-certification/</guid>
      <description>環境  Amazon Linux AMI 2017.03 OpenSSL 1.0.2k-fips 26 Jan 2017   最近はLet&amp;rsquo;s Encryptの登場でめっきり出番が少なくなったオレオレ証明書を作ります。
Let&amp;rsquo;s EncryptのSSL証明書の方が信頼度が高くブラウザ側で設定する必要がありません。
インターネットに公開していない環境でもDNSにTXTレコードを追加すればLet&amp;rsquo;s Encryptの証明書を発行できます。
それでもオレオレ証明書を使いたい人向けの手順です。
オレオレ証明書(自己証明書)とは SSL証明書はどこかしらの認証局(CA)に認証して貰って発行されるのですが、
自分でCAを立てて自分で認証したSSL証明書を発行してしまうというものです。
ざっくりとした流れは以下の通りです。
①オレオレ認証局を立てる
②オレオレ認証局でオレオレ証明書を発行する
③利用ブラウザにオレオレ認証局を認めさせる
以降の手順では「*.hoge.com」というワイルドカードのSSL証明書を作る前提とします。
「*.hoge.com」の部分は作成したいドメインに置き換えてください。
作業ディレクトリ等の準備 EC2にSSHでログインし、以下の通り準備をします。
オレオレ認証局はhogeCAというディレクトリに作成するものとします。
sudo -i cd /etc/pki cp -r CA hogeCA cp tls/openssl.cnf hogeCA/. cd hogeCA touch index.txt echo &amp;quot;00&amp;quot; &amp;gt; serial また、以前は無かったと思うのですが
最近のブラウザはSAN(subjectAltName)というものを設定しておかないと正規の証明書と認めてくれないようです。
SANを設定するためのファイルを作成しておきます。
echo &amp;quot;subjectAltName=DNS:*.hoge.com&amp;quot; &amp;gt; san.ext openssl設定変更 以下の通り、今回利用するopenssl.cnfを修正します。
vim ./openssl.cnf [ CA_default ]セクション修正 作業ディレクトリを変更します。
dir = /etc/pki/hogeCA [ req_distinguished_name ]セクション修正 今回の手順で会社所在地などを複数回聞かれるので、デフォルト値を設定しておきます。</description>
    </item>
    
    <item>
      <title>AWS S3を使ったリダイレクトの方法</title>
      <link>/posts/2020/06/10/aws-s3-redirect/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/06/10/aws-s3-redirect/</guid>
      <description>AWS S3上に置いていた静的コンテンツを部分的に別サーバー等に移設した際など
特定のパスへのアクセスを別サーバー等にリダイレクトする設定です。
対象のS3の
「プロパティ」＞「Static website hosting」＞「このバケットを使用してウェブサイトをホストする」
にリダイレクトルールという欄があるので、以下のように設定します。
この例では①〜③のリダイレクトルール(RoutingRule)を設定しています。
&amp;lt;RoutingRules&amp;gt; &amp;lt;RoutingRule&amp;gt;　・・・① &amp;lt;Condition&amp;gt; &amp;lt;KeyPrefixEquals&amp;gt;kokojanai_dokoka.html&amp;lt;/KeyPrefixEquals&amp;gt; &amp;lt;/Condition&amp;gt; &amp;lt;Redirect&amp;gt; &amp;lt;Protocol&amp;gt;https&amp;lt;/Protocol&amp;gt; &amp;lt;HostName&amp;gt;new-server.co.jp&amp;lt;/HostName&amp;gt; &amp;lt;ReplaceKeyWith&amp;gt;kokodayo.html&amp;lt;/ReplaceKeyWith&amp;gt; &amp;lt;/Redirect&amp;gt; &amp;lt;/RoutingRule&amp;gt; &amp;lt;RoutingRule&amp;gt;　・・・② &amp;lt;Condition&amp;gt; &amp;lt;HttpErrorCodeReturnedEquals&amp;gt;403&amp;lt;/HttpErrorCodeReturnedEquals&amp;gt; &amp;lt;/Condition&amp;gt; &amp;lt;Redirect&amp;gt; &amp;lt;Protocol&amp;gt;https&amp;lt;/Protocol&amp;gt; &amp;lt;HostName&amp;gt;new-server.co.jp&amp;lt;/HostName&amp;gt; &amp;lt;/Redirect&amp;gt; &amp;lt;/RoutingRule&amp;gt; &amp;lt;RoutingRule&amp;gt;　・・・③ &amp;lt;Condition&amp;gt; &amp;lt;HttpErrorCodeReturnedEquals&amp;gt;404&amp;lt;/HttpErrorCodeReturnedEquals&amp;gt; &amp;lt;/Condition&amp;gt; &amp;lt;Redirect&amp;gt; &amp;lt;Protocol&amp;gt;https&amp;lt;/Protocol&amp;gt; &amp;lt;HostName&amp;gt;new-server.co.jp&amp;lt;/HostName&amp;gt; &amp;lt;/Redirect&amp;gt; &amp;lt;/RoutingRule&amp;gt; &amp;lt;/RoutingRules&amp;gt;  ①特定パスへのアクセス 特定のパスへアクセスがあった際にパスを書き換えてリダイレクトします。
S3から新サーバー等に移設した際にパスが変わった場合などに使えます。
設定する値は以下の通りです。
   設定項目 設定値 サンプル値     KeyPrefixEquals このパスにアクセスがあったらリダイレクトします。 kokojanai_dokoka.html   Protocol リダイレクト先のプロトコルです https   HostName リダイレクト先のホスト名です new-server.co.jp   ReplaceKeyWith KeyPrefixEqualsの値をこの値で置き換えます。 kokoday.</description>
    </item>
    
    <item>
      <title>Serverless Frameworkを使ってLambda &amp; API Gatewayをデプロイする</title>
      <link>/posts/2020/05/19/serverless-framework-lambda/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/05/19/serverless-framework-lambda/</guid>
      <description>環境 ubuntu 20.04 LTS
 Serverless Frameworkというサーバーレス環境を簡単に構築できるツールがあります。
https://www.serverless.com/framework/docs/
今回はそれを使ってAWS上にLambda &amp;amp; API Gatewayを使ったサーバーレスAPIを作ってみます。
事前準備(awscliの準備) Serverless Frameworkはaws cliを使ってデプロイするので、インストールしておく必要があります。
既に作業PC等でawscliを使える状態であれば本手順は飛ばして大丈夫です。
awscliのインストール 公式ページの手順を実施します。
https://docs.aws.amazon.com/ja_jp/cli/latest/userguide/install-cliv2-linux.html
$ curl &amp;quot;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip&amp;quot; -o &amp;quot;awscliv2.zip&amp;quot; $ unzip awscliv2.zip $ sudo ./aws/install これでawscliのインストールが出来ました。
念の為バージョンを確認しておきます。
$ aws --version aws-cli/2.0.14 Python/3.7.3 Linux/5.4.0-31-generic botocore/2.0.0dev18 アクセスキーの準備 awscliで利用するアクセスキーをAWS IAMで生成します。
手順は公式ページにあります。
https://docs.aws.amazon.com/ja_jp/cli/latest/userguide/cli-chap-configure.html#cli-quick-configuration
ざっくりいうと、以下の作業をします。
①IAMへアクセス
②アクセスキーを発行するユーザーを選択する。
③「認証情報」タブの「アクセスキーの作成」をクリックする。
④表示されるアクセスキーID/シークレットアクセスキーをメモしておく。
以上です。
awscliの設定 IAMで取得したアクセスキーとリージョン情報をawscliに設定します。
$ aws configure AWS Access Key ID [None]: YOUR-ACCESS-KEY-ID AWS Secret Access Key [None]: YOUR-SECRET-ACCESS-KEY Default region name [None]: ap-northeast-1 Default output format [None]: ※output formatを空のままエンターするとjsonになる。</description>
    </item>
    
    <item>
      <title>GitHub ActionsでAWS Code Deployを回す</title>
      <link>/posts/2020/03/15/github-actions-deploy/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/03/15/github-actions-deploy/</guid>
      <description>GitHub ActionsからAWSコマンドを簡単に叩けるようだったので試してみました。
今回CIでやることは『masterにプッシュされたらCodeDeployを走らせる』のみです。
AWS Code Deployの設定 こちらの記事で手順を紹介しています。
AWS Code DeployでEC2にデプロイする
AWS IAMの設定 こちらの記事で手順を紹介しています。
今回CircleCIは使わないので、「IAM準備」の手順のみ参照してください。
CircleCIからAWS Code Deployを実行する
GitHub Secretsへのキー登録 前手順で取得したIAMユーザーの『アクセスキーID』と『シークレットアクセスキー』をGitHubのSecretsに登録します。
まず、GitHubの対象リポジトリの『Settings ＞ Secrets』を開き、『Add a new secret』をクリックします。
Secretsの設定画面になるので以下2つを設定します。
   Name Value     AWS_ACCESS_KEY_ID IAMのアクセスキーID   AWS_SECRET_ACCESS_KEY IAMのシークレットアクセスキー    GitHub Actionsの設定 デプロイしたいリポジトリのGitHubページの『Actions』タブを開き、
「Set up a workflow yourself」をクリックします。
.github/workflows/main.ymlの編集画面が開くので、以下のように記載します。
name: AWS Code Deploy on: push: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps: - name: Run AWS CodeDeploy with: args: deploy create-deployment --application-name &amp;quot;※APP_NAME※&amp;quot; --deployment-group-name &amp;quot;※GROUP_NAME※&amp;quot; --github-location repository=&amp;quot;※REPO※&amp;quot;,commitId=&amp;quot;${{ github.</description>
    </item>
    
    <item>
      <title>lightsail上に自前でWordpressを構築する(CentOS編)</title>
      <link>/posts/2020/02/18/lightsail-wordpress/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/02/18/lightsail-wordpress/</guid>
      <description>環境  CentOS Linux release 7.6.1810 (Core) nginx 1.1.17 php 7.4.2 MySQL 8.0.19   以前の記事でAmazon Linux上でWordpressを構築しましたが、
lightsailのAmazon Linux上だとなぜかcertbotが正常に動かなくなったので
CentOSで再構築することにしました。
インスタンス作成 lightsailのインスタンスを作成します。
プラットフォーム：Linux/Unix
設計図の選択：OSのみ CentOS
インスタンス設定 作成したインスタンスの設定をします。
対象インスタンスのネットワーキングを開き、静的IPをアタッチしておきます。
また、HTTPSで公開する場合はファイアウォールにてTCPの443ポートを開けておきます。
サーバーへのログイン＆初期設定 インスタンスにSSHにて接続し、以下コマンドを実行していきます。
まずrootになります。
以降のコマンドはrootで実行するものとします。
$ sudo -i タイムゾーンを日本にします。
# timedatectl set-timezone Asia/Tokyo 基本的なアプリケーションを入れておきます。
yum install git vim SELinuxの無効化 SELinuxがあると色々動かないことがあるので無効にしてしまいます。
(nginxが403になったり)
ちゃんとセキュアな環境を作りたい場合はSELinuxが有効でもちゃんと諸々動く環境を作った方がいいですが、
今回はそこまででは無かったので割愛しています。
現在有効か確認します。
以下コマンドで「Enforcing」と出たら有効です。
# getenforce Enforcing 設定ファイルを修正して無効にします。
# vim /etc/selinux/config 以下部分を修正します。 SELINUX=disabled これでlightsailのコンソールからインスタンスを再起動をすると反映されます。
nginxのインストール 公式の手順を参考にします。
http://nginx.org/en/linux_packages.html#RHEL-CentOS
# yum install yum-utils # vim /etc/yum.</description>
    </item>
    
    <item>
      <title>lightsail上に自前でWordpressを構築する(Amazon Linux編)</title>
      <link>/posts/2019/12/15/lightsail-wordpress/</link>
      <pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/12/15/lightsail-wordpress/</guid>
      <description>環境 Amazon Linux AMI 2018.03 (lightsail)
  ※2020年2月追記
lightsailのAmazon Linuxでcretbotの挙動があやしくなってきたので
CentOS版も作りました。
記事はこちら
 lightsailではWordpressを載せたインスタンスを生成できますが、
全部載せbitnami環境があまり好きではなかったので
空のインスタンスに自分でWordpress環境を構築しました。
構築する環境は
nginx + php-fpm(PHP7.2)
とします。
インスタンス作成 lightsailのインスタンスを作成します。
プラットフォーム：Linux/Unix
設計図の選択：OSのみ Amazon Linux
インスタンス設定 作成したインスタンスの設定をします。
対象インスタンスのネットワーキングを開き、静的IPをアタッチしておきます。
また、HTTPSで公開する場合はファイアウォールにてTCPの443ポートを開けておきます。
各種インストール＆設定 インスタンスにSSHにて接続し、以下コマンドを実行していきます。
まずrootになります。
sudo -i いろいろインストールします。
yum install -y git nginx php72-fpm php72-bcmath php72-cli php72-common php72-devel php72-gd php72-json php72-mbstring php72-mysqlnd php72-pdo php72-xml mysql-server nginxの設定 nginxの設定ファイルを追加します。
ファイル名の.confより前は任意です。
vim /etc/nginx/conf.d/wordpress.conf 以下のように記載します。
(Wordpressおきまりのやつです)
server { listen 80; listen [::]:80; server_name your-domain.jp; root /usr/share/nginx/html; index index.</description>
    </item>
    
    <item>
      <title>LightsailにOpenVPNサーバーを立てる</title>
      <link>/posts/2019/07/25/lightsail-vpn/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/07/25/lightsail-vpn/</guid>
      <description>環境  Amazon Linux AMI release 2018.03 openvpn 2.4.4  参考  LightsailでVPN Serverを構築する|memoTech AmazonLinuxにOpenVPNサーバを構築する|ねこの足跡R   国内のVPNサービスを契約していたのですが
同時に1デバイスしか接続できないし、回線がめっちゃ遅かったので
自前でVPNサーバーを立てることにしました。
AWSのLightsail上にOpenVPNでサーバーを立てて
Linux Mint, Android, iPhoneで接続できるようにします。
インスタンス設定 新規インスタンス作成 Lightsailのページにて『インスタンスの作成』をクリックします。
https://lightsail.aws.amazon.com/ls/webapp/home/instances
インスタンスイメージとして以下を選択します。
 Lunux/Unix OSのみ Amazon Linux  インスタンスプランはVPNの利用予定に合わせて選びます。
個人でちょっと使う程度であれば最安のプランでよいと思います。
インスタンス名を適当につけて「インスタンスを作成」をクリックします。
静的IPの設定 インスタンス一覧画面に戻るので
先程作成したインスタンスの「︙」から『管理』をクリックします。
ネットワーキングタブを開き、「静的IPの作成」をクリックします。
静的IPの設定画面になるので、適用するインスタンス（今作ったインスタンス）と
静的IPの名前を決めて「作成」をクリックします。
ポート開放 対象インスタンスの『ネットワーキング』タブを開きます。
ファイアウォールの「＋追加」をクリックし、TCPの1194ポートを開きます。
Lightsailへの接続 インスタンス一覧にて再度「︙」から『接続』をクリックします。
別ウィンドウでターミナル調のブラウザが立ち上がるので、以降の作業を実施します。
手元のターミナルからsshで繋いでも良いです。
Lightsailの時刻を日本時間に合わせる 念の為タイムゾーンを日本にしておきます。
sudo cp -p /usr/share/zoneinfo/Japan /etc/localtime sudo service rsyslog restart sudo service crond restart OpenVPN設定 OpenVPNインストール 以下コマンドを実行します。</description>
    </item>
    
    <item>
      <title>CircleCIからAWS Code Deployを実行する</title>
      <link>/posts/2019/03/04/aws-code-deploy-circleci/</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/03/04/aws-code-deploy-circleci/</guid>
      <description>前記事にてCodeDeployの設定は完了したので、それをCircleCIから実行します。
公式の手順ではS3に一度ソースコードを置いてからEC2に展開しているのですが、
できればS3は使いたくなかったのでこちらの記事を参考にしました。
CircleCI+AWS-CodedeployでStaging環境などに自動デプロイさせる
IAM準備 CircleCI用のIAMユーザーを作成します。
まず適当なユーザー名をつけ、アクセスの種類は『プログラムによるアクセス』にチェックをつけ次のステップへ進みます。
既存ポリシーの『AWSCodeDeployFullAccess』を付与して次のステップへ進みます。
タグは不要なので、そのまま次のステップに進んで大丈夫です。
ユーザーの作成をします。
作成したユーザーの「アクセスキーID」と「シークレットアクセスキー」をメモして終了です。
※シークレットアクセスキーはこのタイミングでしか確認できないので忘れないよう注意
CircleCIの設定ファイル作成 リポジトリ内に.circleci/config.ymlを作成し、以下のように記載します。
version: 2 jobs: deploy: docker: - image: cdssnc/aws-cli steps: - run: name: &amp;quot;Set AWS region&amp;quot; command: aws configure set region ap-northeast-1 - run: name: &amp;quot;Run AWS CodeDeploy&amp;quot; command: aws deploy create-deployment --application-name ${DEPLOY_APPLICATION} --deployment-group-name ${DEPLOY_GROUP} --github-location repository=&amp;quot;${DEPLOY_REPOSITORY}&amp;quot;,commitId=&amp;quot;${CIRCLE_SHA1}&amp;quot; workflows: version: 2 build_deploy: jobs: - deploy: filters: branches: only: master AWS CodeDeployをキックすることしか記載していないので、他にも処理が必要な場合は追記してください。
なお、以下の値は後ほどCircleCIの環境変数にて設定するので変数にしています。
変数にせずに直接config.ymlに書き込んでも良いです。
   変数名 内容     DEPLOY_APPLICATION 前記事にて設定したCodeDeployのアプリケーション名   DEPLOY_GROUP 前記事にて設定したCodeDeployのデプロイグループ   DEPLOY_REPOSITORY デプロイ対象のGitHubリポジトリ(「ユーザー名/リポジトリ名」形式)    作成できたらGitHubのmasterブランチにプッシュしておきます。</description>
    </item>
    
    <item>
      <title>AWS Code DeployでEC2にデプロイする</title>
      <link>/posts/2019/02/28/aws-code-deploy/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/02/28/aws-code-deploy/</guid>
      <description>運用していたEC2へのソースコードを反映するのにCodeDeployを導入してみたので、その作業メモです。
とてもシンプルな状態で試したので、環境は以下の通りです。
 EC2インスタンスは１台のみ ELBの利用なし ソースコードはGitHubより取得する デプロイはソースコードをサーバー上に置くのみ デプロイの実行はAWSのコンソールから手動で実行する。  ※CircleCI連携についてはコチラ
IAM準備 EC2用とCodeDeploy用のロールを準備します。
まずEC2用のロールを作成します。
IAMロール作成画面にてAWSサービス ＞ EC2を選び、次のステップへ進みます。
ポリシーはAmazonEC2RoleforAWSCodeDeployを指定して、次のステップへ進みます。
タグは未指定でも良いので、必要なければ次のステップに進みます。
適当なロール名を決めて設定し、『ロールの作成』をクリックします。
次にCodeDeploy用のロールを作成します。
IAMロール作成画面にてAWSサービス ＞ CodeDeployを選びます。
画面が下へスクロールしてユースケースの選択が表示されます。
今回は純粋なEC2上のボリュームにデプロイするだけなので、CodeDeployを指定して次のステップへ進みます。
ポリシーはAWSCodeDeployRoleが表示されるので、そのまま次のステップへ進みます。
適当なロール名を決めて設定し、『ロールの作成』をクリックします。
EC2準備 まず、EC2インスタンスに管理コンソールからロール付与します。
管理コンソールにて対象インスタンスを開いて以下をクリックします。
アクション ＞ インスタンスの設定 ＞ IAMロールの割り当て/置換
そこで先ほど作成したEC2用のロールを設定します。
次にコンソールにて対象インスタンスにログインし、CodeDeployのエージェントをインストールします。
ダウンロードするインストーラーはrubyが無いと動かないので、インストールされていない場合はインストールしておきます。
$ sudo yum install ruby # rubyがインストールされてない場合 $ sudo yum install aws-cli # aws-cliがインストールされていない場合 $ aws s3 cp s3://aws-codedeploy-ap-northeast-1/latest/install . --region ap-northeast-1 $ chmod +x ./install $ sudo ./install auto インストールが完了したら念の為動作している事を確認する。
$ sudo service codedeploy-agent status The AWS CodeDeploy agent is running as PID 12345 もし上記のロール割り当てより先にCodeDeployエージェントを起動してしまった場合は、</description>
    </item>
    
    <item>
      <title>【Let&#39;sEncrypt】Amazon Linux2でCertbotを使う</title>
      <link>/posts/2019/01/21/certboy-amazon-linux-2/</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/01/21/certboy-amazon-linux-2/</guid>
      <description>事象 Amazon Linux 2で従来の方法でcertbotをインストールすると
コマンド時に以下のエラーが出て使えませんでした。
Sorry, I don&#39;t know how to bootstrap Certbot on your operating system! You will need to install OS dependencies, configure virtualenv, and run pip install manually. Please see https://letsencrypt.readthedocs.org/en/latest/contributing.html#prerequisites for more info. 従来の方法はこちら
解決方法 以下の方法でcertbotをインストールすれば正常に使えました。
curl -O http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm sudo yum install epel-release-latest-7.noarch.rpm sudo yum install certbot 参考 serverfault</description>
    </item>
    
    <item>
      <title>Wordpressの画像をS3&#43;CloudFrontで配信する</title>
      <link>/posts/wp/1772/</link>
      <pubDate>Tue, 11 Dec 2018 19:30:54 +0000</pubDate>
      
      <guid>/posts/wp/1772/</guid>
      <description>環境 WordPress 4.8.3
 AWS設定手順 IAM設定 まず、WordpressとAWSの連携に使うIAMユーザーを準備します
今回の手順ではバケット側のポリシーで権限付与するので
IAM側の権限設定は適当で良いです
準備したIAMユーザーの以下を控えておいてください
・ARN
・アクセスキーID
・シークレットアクセスキー
S3設定 次にS3にてWordpress用のバケットを用意し
バケットポリシーに以下を設定します
{ &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;, &amp;quot;Statement&amp;quot;: [ { &amp;quot;Sid&amp;quot;: &amp;quot;AllowBucketAccess&amp;quot;, &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;, &amp;quot;Principal&amp;quot;: { &amp;quot;AWS&amp;quot;: &amp;quot;arn:aws:iam::準備したIAMのARN&amp;quot; }, &amp;quot;Action&amp;quot;: [ &amp;quot;s3:GetBucketLocation&amp;quot;, &amp;quot;s3:ListBucket&amp;quot;, &amp;quot;s3:PutObject&amp;quot;, &amp;quot;s3:PutObjectAcl&amp;quot;, &amp;quot;s3:GetObject&amp;quot;, &amp;quot;s3:DeleteObject&amp;quot; ], &amp;quot;Resource&amp;quot;: [ &amp;quot;arn:aws:s3:::対象のバケット/*&amp;quot;, &amp;quot;arn:aws:s3:::対象のバケット&amp;quot; ] } ] } CloudFront設定 ユーザーにS3へ直接画像を取りに来させる事も可能なのですが
転送料金が結構高くなるのでCloudFront経由でS3に繋がせるようにします
まずloudFrontの設定画面にて「Create Distribution」をクリックします
 次にWebの「Get Started」をクリックします。
 「Origin Domain Name」にCloud Front経由にしたいS3バケットを指定します
テキストボックスに見えますが、クリックすると選択肢が表示されます
「Origin Domain Name」を選択すると、「Origin ID」にも勝手に値が入ります
 上記入力したら下までスクロールして「Create Distribution」をクリックします
CloudFrontの一覧に戻りますので</description>
    </item>
    
    <item>
      <title>AWS ELB配下でWordpressを動かす際のSSL対応</title>
      <link>/posts/wp/1439/</link>
      <pubDate>Fri, 20 Jul 2018 17:56:57 +0000</pubDate>
      
      <guid>/posts/wp/1439/</guid>
      <description>■環境 AWS ELB
AWS EC2
Apache 2.2.32
Wordpress 4.1.1
 EC-CUBEではありませんが、内容的にはほぼ以下の伊賀もの様の記事通りです。
続カッコの付け方WordpressでもリクエストURLを見ており、httpsでアクセスした場合のみhttpsでCSSを取得するようになっているのですが
AWS ELBがポートを80に変えてしまうため以下の事象が起こります。
① ChromeでHTTPSのWordpressページを開く
② WordpressがCSSなどはHTTPで取得するよう返す
③ Chrome様が『HTTPSのページのリソースはHTTPSで取得せぇや！』と怒る
※ELB周りの話はこちらでも書いてます
AWS ELB配下でApacheのRewriteRuleが上手く動かなかった話対応方法上記記事同様に、Wordpress（Ver4.1.1時点）でも $_SERVER[&amp;lsquo;HTTPS&amp;rsquo;]を見ているので、
Apacheの設定（.htaccessでも可）で書き換えてしまえば解決です。
# ELBがhttpsで受けている場合はHTTPSを有効にする SetEnvIf X-Forwarded-Proto ^https$ HTTPS=on # httpアクセスはhttpsにリダイレクトする(設定するかは任意) RewriteEngine on RewriteCond %{HTTP:X-Forwarded-Proto} ^http$ RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [R,L] </description>
    </item>
    
    <item>
      <title>AWS ELB配下でApacheのRewriteRuleが上手く動かなかった話</title>
      <link>/posts/wp/1423/</link>
      <pubDate>Sat, 30 Jun 2018 22:29:41 +0000</pubDate>
      
      <guid>/posts/wp/1423/</guid>
      <description>■環境 AWS ELB
AWS EC2
Apache 2.2.32
 AWSのEC2上で動いているApacheサーバーでの話。
SEO対策で/index.htmlを/にリダイレクトしたかったので
.htaccessに以下を設定しました。
RewriteRule ^(.*)index.html$ $1 [R=301,L] 検証インスタンスでは上手く動いたので、本番インスタンスにも反映させたところ
https://〜/index.html(443ポート) が http://〜/(80ポート)にリダイレクトされるようになってしまいました。
なんでだろう？と思いながら以下のような分岐を作ってみましたが、結果は変わらずでした。
# 一旦プロトコルはhttpとしておく RewriteRule .* - [E=X_PRTCL:http] # リクエストプロトコルがhttpsの場合、リダイレクト先もhttpsにする RewriteCond %{HTTPS} on RewriteRule .* - [E=X_PRTCL:https] RewriteRule ^(.*)index.html$ %{ENV:X_PRTCL}://%{HTTP_HOST}/$1 [R=301,L] なぜ443ポート(https)の通信が80ポート(http)扱いになってしまったかというと
本番環境のEC2はELBを通しているのが原因でした。
つまり、検証環境では
PC ↓443ポート EC2 だったのに対して、本番環境では
PC ↓443ポート ELB ↓80ポート EC2 となっていたのでした。
ELBを経由した場合、HTTPプロトコルを判定するにはX-Forwarded-Protoというパラメータを見る必要があるようです。
https://docs.aws.amazon.com/ja_jp/elasticloadbalancing/latest/classic/x-forwarded-headers.html以下のようにhtaccessへ記載すればELB経由でも上手く動きました
# 一旦プロトコルはhttpとしておく RewriteRule .* - [E=X_PRTCL:http] # リクエストプロトコルがhttpsの場合、リダイレクト先もhttpsにする RewriteCond %{HTTPS} on [OR] # ELBを経由しない時用 RewriteCond %{HTTP:X-Forwarded-Proto} https # ELBを経由する時用 RewriteRule .</description>
    </item>
    
    <item>
      <title>【AWS】新規EC2立ち上げ後の作業メモ</title>
      <link>/posts/wp/820/</link>
      <pubDate>Sun, 12 Nov 2017 01:06:50 +0000</pubDate>
      
      <guid>/posts/wp/820/</guid>
      <description>環境 AWS EC2
Amazon Linux
 セキュリティグループ設定 SSH接続元やHTTP通信元の設定をする。 デフォルトではEC2を立ち上げた際のアクセス元に対してSSH接続が許可されているのみ。
立ち上げたEC2へのSSH接続 以下の通りSSH接続を実施する。 ログインアカウント：ec2-user 秘密鍵：EC2立ち上げ時にダウンロードしたpemファイル ※pemファイルはDL後権限を400にしておくこと。
rootになり、パスワードを変更する。 $ sudo su - # passwd 日本時刻にする。(rootのまま実施) # cp -p /usr/share/zoneinfo/Japan /etc/localtime # service rsyslog restart # service crond restart ※localtime変更後はrsyslogとcrondを再起動しないと、ログ出力時刻やcron実行時刻が日本時刻にならない。</description>
    </item>
    
  </channel>
</rss>
